#! /usr/bin/env bash

#
# Execute all jobs by directly running them from the current shell
#


if [[ -z "$1" ]]; then
	DIRS=job_bench*
else
	DIRS=$@
fi

P="$(pwd)"
for JOBDIR in $DIRS; do
	cd "$JOBDIR" || exit 1

	echo_info "Executing job in directory '$JOBDIR'"

	function kill_job()
	{
		GRANDCHILD_PIDS=`pgrep -P $SCRIPT_PID`
		echo "Sending TERM signal to grandchild jobs $GRANDCHILD_PIDS"

		echo "$GRANDCHILD_PIDS" | xargs kill -TERM

		exit -1
	}

	trap kill_job SIGINT

	./run.sh 2>"output.err" > "./output.out" &
	#./run.sh 2>"output.err" &
	#./run.sh > "./output.out" &
	SCRIPT_PID=$!

	sleep 10


        # Wait for finish
        wait $SCRIPT_PID

	EXIT_CODE=$?

	if [[ 0 -ne $EXIT_CODE ]]; then
		tail -n 100 "output.out"
		tail -n 100 "output.err"
		echo_error_hline
		echo_error "ERROR during job execution (see above)"
		echo_error " See output.out and output.err in job directory for full output"
		echo_error_hline
		echo_error " Job directory: '$JOBDIR'"
		echo_error_hline
		exit 1
	fi

	cd "$P"
done

